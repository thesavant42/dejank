// Package envars extracts environment variables from bundled JavaScript files.
// Bundlers like webpack, Vite, esbuild, and Rollup inline environment variables
// at build time, replacing process.env.VAR or import.meta.env.VAR with literal values.
package envars

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// Known environment variable prefixes from common bundlers
var knownPrefixes = []string{
	"NODE_ENV",
	"PUBLIC_URL",
	"REACT_APP_",
	"NEXT_PUBLIC_",
	"VITE_",
	"VUE_APP_",
	"NUXT_PUBLIC_",
	"WDS_",
	"FAST_REFRESH",
	"GATSBY_",
	"EXPO_PUBLIC_",
}

var (
	// Matches individual key:value pairs that look like env vars
	// Handles: KEY:"value", KEY:'value', KEY:value, KEY:void 0, KEY:!0, KEY:!1
	// We match directly without trying to find object boundaries first
	keyValuePattern = regexp.MustCompile(`([A-Z][A-Z0-9_]*)\s*:\s*(?:"([^"]*)"|'([^']*)'|void\s+0|(![01])|([^,}\s]+))`)
)

// ExtractResult contains extracted environment variables and metadata.
type ExtractResult struct {
	Vars       map[string]string
	SourceFile string
}

// ExtractEnvVars extracts inlined environment variables from bundled JavaScript content.
// It looks for webpack/Vite/esbuild style key:value patterns matching known env var prefixes.
func ExtractEnvVars(jsContent string) map[string]string {
	result := make(map[string]string)

	// Find all key:value pairs in the content
	kvMatches := keyValuePattern.FindAllStringSubmatch(jsContent, -1)

	for _, kv := range kvMatches {
		if len(kv) < 2 {
			continue
		}

		key := kv[1]

		// Only include known env var prefixes
		if !isKnownEnvVar(key) {
			continue
		}

		// Determine the value from capture groups
		var value string
		switch {
		case kv[2] != "": // Double-quoted string
			value = kv[2]
		case kv[3] != "": // Single-quoted string
			value = kv[3]
		case kv[4] != "": // Boolean (!0 or !1)
			if kv[4] == "!0" {
				value = "true"
			} else {
				value = "false"
			}
		case kv[5] != "": // Other value (number, identifier, void 0)
			val := strings.TrimSpace(kv[5])
			if val == "void" || strings.HasPrefix(val, "void ") {
				value = "undefined"
			} else {
				value = val
			}
		default:
			continue
		}

		// Don't overwrite existing values (first occurrence wins)
		if _, exists := result[key]; !exists {
			result[key] = value
		}
	}

	return result
}

// isKnownEnvVar checks if a key matches known environment variable patterns.
func isKnownEnvVar(key string) bool {
	for _, prefix := range knownPrefixes {
		if strings.HasPrefix(key, prefix) || key == strings.TrimSuffix(prefix, "_") {
			return true
		}
	}
	return false
}

// MergeEnvVars merges multiple env var maps, with earlier maps taking precedence.
func MergeEnvVars(maps ...map[string]string) map[string]string {
	result := make(map[string]string)

	// Process in reverse order so earlier maps overwrite later ones
	for i := len(maps) - 1; i >= 0; i-- {
		for k, v := range maps[i] {
			result[k] = v
		}
	}

	return result
}

// WriteEnvFile writes extracted environment variables to a .env file.
func WriteEnvFile(vars map[string]string, outputPath string) error {
	if len(vars) == 0 {
		return nil
	}

	// Ensure parent directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Sort keys for consistent output
	keys := make([]string, 0, len(vars))
	for k := range vars {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// Build file content
	var sb strings.Builder
	sb.WriteString("# Extracted environment variables from bundled JavaScript\n")
	sb.WriteString("# Generated by dejank\n")
	sb.WriteString("# WARNING: May contain sensitive values (API keys, secrets)\n\n")

	for _, key := range keys {
		value := vars[key]
		// Escape special characters in values
		escapedValue := escapeEnvValue(value)
		sb.WriteString(fmt.Sprintf("%s=%s\n", key, escapedValue))
	}

	return os.WriteFile(outputPath, []byte(sb.String()), 0644)
}

// escapeEnvValue escapes a value for safe inclusion in a .env file.
func escapeEnvValue(value string) string {
	// If value contains special characters, quote it
	needsQuotes := strings.ContainsAny(value, " \t\n\r\"'$`\\#")

	if !needsQuotes {
		return value
	}

	// Use double quotes and escape internal double quotes and backslashes
	escaped := strings.ReplaceAll(value, "\\", "\\\\")
	escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
	escaped = strings.ReplaceAll(escaped, "\n", "\\n")
	escaped = strings.ReplaceAll(escaped, "\r", "\\r")

	return "\"" + escaped + "\""
}

